#!/usr/bin/python3 -B
import os
import re
import sys
import json
import shutil
import tempfile
import subprocess
import urllib.request
from pathlib import Path
from collections.abc import Iterable
from contextlib import suppress, contextmanager

# exclude dist-packages, make sure only std libraries are used
sys.path = [p for p in sys.path if not re.search(r'/dist-packages$', p)]


CMD_ALIASES = {'install': 'add', 'remove': 'del', 'uninstall': 'del'}
INSTALL_SPEC_CACHE = 'install-command-spec.json'


def die_usage():
    print("""Usage: petal <command> [args ...]\n
  Create or recover an environment
       petal make [env] [with /usr/bin/python3] [over|on base_env ...]

  Install packages
       petal add [pip install params ...] [to env]
             alias of add command: install

  Remove packages
       petal del package ... [from env]
             aliases of del command: remove, uninstall

  Show packages
       petal show [options] [env]
             -d, --deep     show packages in base environment(s)
             -v, --version  show package version
             -s, --source   show package source

  Print action plans
       petal plan add | del ... [on env]
""".strip())

    sys.exit(1)


class ColorMaker:
    def __init__(self):
        self.istty = sys.stdout.isatty()

    def _color(self, color=0):
        return self.istty and (f'\033[{color}m' if color else '\033[0m') or ''

    def _r(self, txt): return self._color(31) + str(txt) + self._color()
    def _g(self, txt): return self._color(32) + str(txt) + self._color()
    def _y(self, txt): return self._color(33) + str(txt) + self._color()
    def _b(self, txt): return self._color(34) + str(txt) + self._color()
    def _m(self, txt): return self._color(35) + str(txt) + self._color()
    def _c(self, txt): return self._color(36) + str(txt) + self._color()


class Petal(ColorMaker):
    def __init__(self):
        super().__init__()
        self.exit_code = 0
        self.python = '/usr/bin/python3.8'
        self.pypi = os.environ.get('PETAL_PYPI',
                                   'https://pypi.tuna.tsinghua.edu.cn')


    @property
    def user_site(self):
        return re.sub(r'^.+/(lib.+/site-packages)$', r'\1',
                      check_output(f'{self.python} -m site --user-site'))


    @property
    def py_version(self):
        return check_output([self.python, '-c',
            'import sys; v = sys.version_info; print(f"{v[0]}.{v[1]}")'])


    @property
    def default_env(self):
        envs = [d for d in Path(os.getcwd()).iterdir()
                if d.is_dir() and (d / 'pyvenv.cfg').exists()]
        if not envs:
            die('No env found!')
        if len(envs) > 1:
            env_str = ', '.join(self._y(tilde_path(x)) for x in envs)
            die(f'Multiple envs found, you need to choose one from: {env_str}')
        return PetalEnv(envs[0])


    def run(self):
        args = sys.argv[1:]
        if not args:
            die_usage()
        cmd_name = CMD_ALIASES.get(args[0], args[0])
        cmd = getattr(self, f'cmd_{cmd_name}', None)
        if not cmd:
            die(f'invalid command {cmd_name}')
        cmd(args[1:])
        exit(self.exit_code)


    def cmd_make(self, args):
        env_dir = args[0] if args else 'env'
        if not os.path.exists(env_dir):
            if len(args) > 2:
                args = args[1:]
                if 'with' in args:
                    idx = args.index('with') + 1
                    if idx >= len(args):
                        die_usage()
                    self.python = args[idx]
                    if not os.path.exists(self.python):
                        die(f'{self.python} not found!')
                    self.python = os.path.realpath(self.python)
                    args[idx] = ''
                    args[idx-1] = ''
                    args = list(filter(None, args))
                if args[0] not in ['over', 'on'] or len(args) < 2:
                    die_usage()
                layers = args[1:]
            else:
                layers = []
            self.env_new(env_dir, layers)
        else:
            if len(args) > 1:
                die_usage()
            self.env_build(env_dir)


    def cmd_rebuild(self, args):
        if len(args) != 1:
            die_usage()
        env = PetalEnv(args[0])
        print(env.require.pkgs)


    def cmd_show(self, args):
        "Remove pakcages from env"

        opts = [x for x in args if x.startswith('-')]
        args = [x for x in args if not x.startswith('-')]
        show_version = '-v' in opts or '--version' in opts
        deep = '-d' in opts or '--deep' in opts
        show_src = '-s' in opts or '--source' in opts

        # find the env we're working on
        env = PetalEnv(args[0]) if len(args) else self.default_env

        def _pkg_line(p, level, sign='-'):
            prefix = '  ' * level
            name = p.disp
            if show_version:
                name += f' {self._b(p.version)}'
            if p.native:
                line = f'{sign} {name}'
            else:
                line = f'* {name} [{tilde_path(p.env)}]'
            return prefix + line

        explicits = env.explicit_packages(deep=deep)
        if not explicits:
            die('empty env')

        pkgs = PackageSet(env)
        print(f'packages in {self._y(env)}:')
        for xpkg in explicits:
            name = xpkg.name
            pkg = pkgs[name]
            line = (pkg.native and '+ ' or '* ') + self._g(name)
            if show_version:
                line += f' {self._b(pkg.version)}'
            if not pkg.native:
                line += f' [{tilde_path(pkg.env)}]'
            if show_src:
                if not xpkg.src:
                    src = '(manual)'
                else:
                    src = f'(included from {tilde_path(xpkg.src)})'
                line += f' {self._c(src)}'
            print(line)
            for p, level in pkgs.walk(name):
                print(_pkg_line(p, level))

        explicit_names = set(p.name for p in explicits)
        orphans = [p for p in pkgs.orphans()
                   if p.native and p.name not in explicit_names]
        if orphans:
            print('- (orphans)')
            for p in orphans:
                print(_pkg_line(p, 1, '?'))


    def _pstr(self, pkgs):
        "Package display helper"
        if isinstance(pkgs, Iterable):
            return ', '.join(self._g(p) for p in pkgs)
        return self._g(kgs)


    def _run_pip(self, cmd, dry=False):
        run = dry and 'plan to run ' or 'run '
        log(run, self._c('PETAL_USE_CORE=1 ' + tilde_path(' '.join(cmd))))
        if dry:
            return
        code = os_run(cmd, PETAL_USE_CORE=1)
        if code:
            sys.exit(code)


    def cmd_add(self, args, dryrun=False):
        "Install pakcages to env"

        # find the env we're working on
        if len(args) > 2 and args[-2] == 'to':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = self.default_env

        # get requested packages from command line
        installed_pkgs = env.list_installed(deep=False)
        installed = set(pkg.name for pkg in installed_pkgs)
        pip_opts, wanted_specs = env.split_install_args(args)
        wanted = XRequired(wanted_specs)
        if not wanted:
            die('no package to install')

        # filter out installed packages with version specs removed
        new = [p for p in wanted.names if p not in installed]

        # handle promotion: package installed but not in the explicit set
        if not new:
            explicits = set(p.name for p in env.explicit_packages())
            selected = [p for p in wanted.names if p not in explicits]
            if selected:
                if dryrun:
                    log(f'[{env}] plan to promote {self._pstr(selected)}')
                else:
                    env.add(selected, freeze=False)
                    log(f'[{env}] promote {self._pstr(selected)} as explicit')
            else:
                log(dryrun and 'nothing in plan' or 'nothing to change')
            return

        # run pip to install packages
        install_specs = wanted.filter(new).specs
        pip_cmd = env.pip('install', pip_opts + install_specs)
        self._run_pip(pip_cmd, dry=dryrun)
        if dryrun:
            return

        if '--dry-run' not in pip_opts:
            env.add(wanted.lines)
            log(f'[{env}] packages installed: {self._pstr(install_specs)}')


    def cmd_del(self, args, dryrun=False):
        "Remove pakcages from env"

        # find the env we're working on
        if len(args) > 2 and args[-2] == 'from':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = self.default_env

        # installed packages set
        iset = PackageSet(env)
        explicits = env.explicit_packages()
        installed = set(p.name for p in explicits if p.src is None)
        excludes  = set(p.name for p in explicits if p.src is not None)

        # find collateral packages (dependencies) to remove
        wanted = [p.lower() for p in args]
        unknwon = [p for p in wanted if p not in iset]
        if unknwon:
            warn = self._r('unknown packages')
            die(f'[{env}] {warn}: {self._pstr(unknwon)}')

        # prevent removing packages from include entries
        excluded = [p for p in explicits
                    if p.src is not None and p.name in wanted]
        if excluded:
            log('NOT removing included packages:')
            for xpkg in excluded:
                log(f'  {self._g(xpkg.name)}: {self._c(xpkg.src)}')
        wanted = [p for p in wanted if p not in excludes]

        # allow delisting packages without uninstalling them
        wanted_set = set(wanted)
        uninstall = [p for p in wanted if not iset[p].depby - wanted_set]
        delist = [p for p in wanted if p not in uninstall]

        msg = ''
        if uninstall:
            collaterals = set()
            for name in uninstall:
                if not name in iset:
                    die(f'package {self._g(name)} not found in {env}')
                collaterals.update(p for p in iset.dep_on(name))
            removing = set(iset[p] for p in uninstall) | collaterals
            orphans = [p.name for p in collaterals # a package is orphaned if it's:
                       # native (never remove packages in base envs), and
                       if p.native and
                       # not in explicit set, and
                       p.name not in installed and
                       # not needed by any other packages except those on the list
                       not set(iset.dep_by(p.name)) - removing]
            cmd = env.pip('uninstall', ['--yes'] + uninstall + orphans)
            if not dryrun:
                self._run_pip(cmd)
                msg += f'[{env}] uninstalled: {self._pstr(uninstall)}'
            else:
                msg += f'[{env}] plan to uninstall: {self._pstr(uninstall)}'
            if orphans:
                msg += f', with dependencies: {self._pstr(orphans)}'

        real_delist = [p for p in delist if p in installed]
        if real_delist:
            delist = real_delist
            if msg:
                msg += '\n'
            if dryrun:
                msg += f'[{env}] plan to delist {self._pstr(delist)}'
            else:
                msg += f'[{env}] delist {self._pstr(delist)} from explicit set'
        elif not dryrun and delist:
            msg += f'[{env}] ignore {self._pstr(delist)}'

        wanted = uninstall + delist
        if wanted:
            if dryrun:
                log(msg or 'nothing in plan')
            else:
                env.remove(wanted)
                log(msg)
        else:
            log('nothing to change')


    def cmd_plan(self, args):
        "Print action plans"

        if len(args) < 2:
            die_usage()
        cmd = CMD_ALIASES.get(args[0], args[0])
        args = args[1:]
        if cmd == 'add':
            if len(args) > 2 and args[-2] == 'on':
                args[-2] = 'to'
            self.cmd_add(args, dryrun=True)
        elif cmd == 'del':
            if len(args) > 2 and args[-2] == 'on':
                args[-2] = 'from'
            self.cmd_del(args, dryrun=True)
        else:
            die_usage()


    def ensure_core(self):
        env = f'~/.cache/petal.py/core/python{self.py_version}'
        if Path(env).expanduser().exists():
            return env

        error = None
        try:
            self.env_new(env, is_core=True)
        except Exception as e:
            shutil.rmtree(env, ignore_errors=True)
            error = e
        if error:
            raise Error

        return env


    def _ensure_layer(self, layer):
        if not os.path.exists(layer):
            die(f'layer {layer} not found')
        env = PetalEnv(layer)
        if env.py_version != self.py_version:
            path = tilde_path(os.path.realpath(layer))
            die(f'{path} uses python{env.py_version}, need {self.py_version}')


    def env_new(self, path, layers=[], *, is_core=False):
        "make a new petal environment"

        if not os.path.exists(self.python):
            die(f'{self.python} not found')
        for layer in layers:
            self._ensure_layer(layer)

        # calculate base layers' paths
        env = Path(path).expanduser()
        based_on_core = False
        if not is_core:
            core = self.ensure_core()
            if not layers:
                layers = [core]
                based_on_core = True
            layers = [self.calc_layer_path(env, layer) for layer in layers]

        # make PEP-405 virtual env
        make_dir(env / self.user_site)
        make_dir(env / 'bin')
        os.symlink(self.python, env / 'bin' / 'python')
        write_file(env / 'pyvenv.cfg',
                   [f'home = {os.path.dirname(self.python)}',
                    f'include-system-site-packages = false'])

        # bootstrap pip for core env
        if is_core:
            self.bootstrap_pip(os.path.realpath(env))
            log(f'petal core (python{self.py_version}) made: {self._y(path)}')
            return

        # write files for petal env
        conf_layers = [] if based_on_core else layers
        dump_json(env / 'petal.json', {'python': self.py_version,
                                       'bases': conf_layers,
                                       'require': []})
        write_file(env / 'petal.freeze')
        write_file(env / '.gitignore',
                   ["*", "!.gitignore", "!petal.json", "!petal.freeze"])

        msg = f'environment {self._y(path)} made'
        if layers:
            self.install_layers_hack(env)
            msg += (' on top of [%s]' %
                    ', '.join([self._y(layer) for layer in layers]))
        msg += f' with {self._g(self.python)}'

        log(msg)


    def env_build(self, path):
        print('build', path)
        ...


    def calc_layer_path(self, env, layer):
        if layer.startswith('~'):
            return layer
        if layer.startswith('/'):
            return tilde_path(layer)
        return os.path.relpath(layer, env.resolve())


    def bootstrap_pip(self, env):
        "Download pip wheel package and install it."

        data = json.loads(download_url(f'{self.pypi}/pypi/pip/json'))
        pip_url = re.sub(r'https?://[^/]*', self.pypi, data['urls'][0]['url'])
        fname = os.path.basename(pip_url)
        pip_ver = fname.split('-')[1]
        with tempfile.TemporaryDirectory(suffix=".petal") as tmp:
            log('download pip ' + self._b(pip_ver) + f' from {self.pypi}')
            py = f'{env}/bin/python'
            whl = f'{tmp}/{fname}'
            download_url(pip_url, whl)
            os_run(f'{py} {whl}/pip install --no-index -q {whl}')
            # cache pip install command spec
            PetalEnv(env)._get_install_spec()
            log(f'pip bootstrap done for {self._y(env)}')


    def install_layers_hack(self, env):
        "The magic of layered environments."

        site = env / 'lib' / f'python{self.py_version}' / 'site-packages'
        write_file(site / 'petal-layers.pth',
                   "import sys; __import__('_petal_layers').scan_layers()")
        write_file(site / '_petal_layers.py', """
############################ petal layered env hack ############################
import sys, os, json; from pathlib import Path; from contextlib import suppress
envs = set() # mutual inclusion prevention
def scan_layers(root=None):
    global envs
    if root is None:
        scan_layers(Path(__file__).parent.parent.parent.parent)
        envs = set()
        return
    if root in envs:
        return
    envs.add(str(root))
    with suppress(Exception):
        json_conf = root / 'petal.json'
        not_core = json_conf.exists()
        layers = []
        py_version = '.'.join(str(v) for v in sys.version_info[:2])
        libdir = f'python{py_version}'
        if not_core:
            with open(json_conf) as f:
                conf = json.load(f)
            if 'python' not in conf or conf['python'] != py_version:
                return
            bases = conf['bases'] or [f'~/.cache/petal.py/core/{libdir}']
            for d in bases:
                layer = d[0] in ['/', '~'] and Path(d) or root / d
                layer = layer.expanduser().resolve()
                if layer.is_dir():
                    layers.append(layer)
        if not_core or 'PETAL_USE_CORE' in os.environ:
            site_path = root / 'lib' / libdir / 'site-packages'
            if site_path.is_dir():
                path = str(site_path)
                if path not in sys.path:
                    sys.path.append(path)
        for layer in layers: scan_layers(layer)
################################################################################
""")


class Package:
    "Abstraction of single package"

    def __init__(self, pkg):
        self.disp = pkg.project_name
        self.name = self.disp.lower()
        self.env = grep(r'^(.+)/lib/python.+/site-packages', pkg.module_path)
        self.native = True
        self.version = pkg.version
        self.depon = [x.name.lower() for x in pkg.requires()]
        self.depby = set()
    def __str__(self): return self.disp
    def __repr__(self): return f'Package({self.disp})'
    def __hash__(self): return hash(self.name)
    def __eq__(self, rhs): return self.name == rhs.name
    def __lt__(self, rhs): return self.name < rhs.name


class PackageSet:
    "A set of packages with dependency traversing"

    def __init__(self, env, deep=True):
        self.pkgs = {p.name: p for p in env.list_installed(deep=deep)}
        # resolve dependency network
        this_env = str(env.path)
        for name, pkg in self.pkgs.items():
            pkg.native = pkg.env == this_env
            for dep in pkg.depon:
                if dep in self.pkgs:
                    self.pkgs[dep].depby.add(name)

    def __getitem__(self, key):
        return self.pkgs[key.lower()]

    def __contains__(self, key):
        return key.lower() in self.pkgs

    def walk(self, name, level=0):
        "depth first recursive walk"
        pkg = self.pkgs[name]
        for dep in pkg.depon:
            yield (self.pkgs[dep], level + 1)
            yield from self.walk(dep, level + 1)

    def dep_on(self, name):
        "get all dependencies"
        pkg = self.pkgs[name]
        for dep in pkg.depon:
            yield self.pkgs[dep]
            yield from self.dep_on(dep)

    def dep_by(self, name):
        "get all reverse dependencies"
        pkg = self.pkgs[name]
        for dep in pkg.depby:
            yield self.pkgs[dep]
            yield from self.dep_by(dep)

    def orphans(self):
        return sorted([pkg for pkg in self.pkgs.values() if not pkg.depby])


class XPackage:
    "Explicit package: package with explicit source"

    def __init__(self, spec, src=None):
        self._spec = spec
        self.src = str(src) if src else None


    @property
    def name(self):
        return pkg_name(self._spec)


    @property
    def spec(self):
        return self._spec


    def __str__(self):
        spec = self._spec
        if self.src:
            spec += f' (from {str(self.src)})'
        return spec

    def __repr__(self): return str(self)


class XRequired:
    "Explicitly required packages"

    def __init__(self, specs=[], src=None):
        self.lines = []
        self.pkgs = {}
        self.src = src if src else None
        cwd = Path(os.getcwd())
        self.pwd = (Path(src).parent if src else cwd).resolve()
        for spec in specs:
            if not isinstance(spec, str) or not spec:
                continue
            if is_include(spec):
                include = self.pwd / Path(spec)
                if not include.exists():
                    continue
                relpath = os.path.relpath(include.resolve(), cwd)
                inc = XRequired(read_lines(include), src=relpath)
                for name, xpkg in inc.pkgs.items():
                    self.pkgs[name] = xpkg
                line = spec
                if not line.startswith('.'):
                    line = tilde_path(include.resolve())
                self.lines.append(line)
            else:
                self.lines.append(spec)
                self.pkgs[pkg_name(spec)] = XPackage(spec, self.src)


    def __bool__(self):
        return bool(self.pkgs)


    @property
    def names(self):
        return list(self.pkgs.keys())


    @property
    def specs(self):
        return [x.spec for x in self.pkgs.values()]


    @property
    def full(self):
        return list(self.pkgs.values())


    def filter(self, names):
        self.lines = [line for line in self.lines
                      if is_include(line) or pkg_name(line) in names]
        self.pkgs = {k: v for k, v in self.pkgs.items() if k in names}
        return self


class PetalEnv(ColorMaker):
    "Abstraction of Petal Environment"

    def __init__(self, path):
        super().__init__()
        self.path = Path(path).expanduser().resolve()
        if not (self.path / 'pyvenv.cfg').is_file():
            die(f'invalid env {path}')
        env_cfg = self.path / 'petal.json'
        self.cfg = {}
        self.is_core = not env_cfg.exists()
        self.bases = []
        if self.is_core:
            self.py_version = grep(r'^python(\d.+)$', self.path.name)
            self.require = XRequired()
            return
        with open(env_cfg) as f:
            self.cfg = json.load(f)
        self.py_version = self.cfg['python']
        self.require = XRequired(self.cfg['require'])
        with suppress(Exception):
            bases = self.cfg['bases']
            if not bases:
                bases = [f'~/.cache/petal.py/core/python{self.py_version}']
            for d in bases:
                layer = d[0] in ['/', '~'] and Path(d) or self.path / d
                layer = layer.expanduser().resolve()
                if layer.is_dir():
                    self.bases.append(layer)


    @property
    def conf_file(self):
        return self.path / f'petal.json'


    @property
    def freeze_file(self):
        return self.path / f'petal.freeze'


    @property
    def layers(self):
        "Iterate all direct base layers"
        for p in self.bases:
            yield PetalEnv(p)


    @property
    def core(self):
        "Find core env recursively"
        if self.is_core:
            return self
        for e in self.layers:
            # we don't need to loop through all layers
            return e.core
        die('core env not found')


    @property
    def site_path(self):
        "Site Path of this env"
        return self.path / 'lib' / f'python{self.py_version}' / 'site-packages'


    def explicit_packages(self, deep=False):
        "Explicit packages"
        pkgs = self.require.full
        if deep:
            for layer in self.layers:
                pkgs += layer.explicit_packages(deep=True)
        return pkgs


    def paths(self, include_core=True):
        "Site Paths of this env and all base envs"
        if include_core or not self.is_core:
            ret = [str(self.site_path)]
        else:
            ret = []
        for e in self.layers:
            ret += e.paths(include_core)
        return ret


    def pip(self, cmd, args):
        "Return pip command line as a string list"

        python = str(self.path / 'bin' / 'python')
        global_opts = ['--disable-pip-version-check', '--no-input']
        ret = [python, '-m' , 'pip'] + global_opts + [cmd]
        if isinstance(args, list):
            ret += args
        else:
            ret += args.split()
        return ret


    @contextmanager
    def tapped(self):
        orig_path = sys.path
        try:
            sys.path = list(reversed(self.paths())) + sys.path
            yield
        finally:
            sys.path = orig_path


    def list_installed(self, deep=True):
        search_paths = self.paths(include_core=False)
        pkgs = []
        with self.core.tapped():
            from pip._internal.metadata import pkg_resources
            e = pkg_resources.Environment.from_paths(search_paths)
            dists = e.iter_installed_distributions()
            pkgs = [Package(d._dist) for d in dists]
        if deep:
            return pkgs
        return [p for p in pkgs if p.env == str(self.path)]


    def split_install_args(self, args):
        "Split args into pip install options and package names"
        ins_spec = self._get_install_spec()
        idx = set()
        for i in range(len(args)):
            if args[i].startswith('-'):
                idx.add(i)
                if args[i] in ins_spec and i + 1 < len(args):
                    idx.add(i + 1)
        opts, pkgs = [], []
        for i in range(len(args)):
            if i in idx:
                opts.append(args[i])
            else:
                pkgs.append(args[i].lower())
        return (opts, pkgs)


    # We need to extract package names from command line, but in theory all pip
    # install options should be supported.  The solution we adopt is to extract
    # and cache command line switches from `pip install --help` and use those
    # to filter out options.
    def _get_install_spec(self):
        "Return pip install command-line spec of current version of pip"

        cache_fname = self.core.path / INSTALL_SPEC_CACHE
        if not cache_fname.exists():
            write_file(cache_fname, '{}')
        with open(cache_fname) as f:
            cache = json.load(f)
        pip_ver = self._get_pip_version()
        if not pip_ver:
            die(f'failed to get pip version in core env {self.core.path}')
        if pip_ver in cache:
            return cache[pip_ver]

        spec = []
        pip_cmd = self.core.pip('install', '--help')
        for x in check_output(pip_cmd).split('\n'):
            # this regexp filters out all options with argument
            if re.match('^\s{2,4}-[^ ].+\s+<[^ ]+>', x):
                spec += [c.strip(',') for c in x.split() if c.startswith('-')]
        spec = sorted(spec)

        # cache the result
        cache[pip_ver] = spec
        dump_json(cache_fname, cache)

        return spec


    def _get_pip_version(self):
        "Look up pip version in core env"
        if self.core is None:
            die(f'core env not found for {self.path}')
        for d in self.core.site_path.iterdir():
            if d.is_dir():
                version = grep(r'^pip-(.+)\.dist-info$', d.name)
                if version:
                    return version
        return None


    def add(self, pkg_specs, freeze=True):
        if not isinstance(pkg_specs, list):
            self.add([pkg_specs], freeze=freeze)
            return
        specs = {name: pkg.spec for name, pkg in self.require.pkgs.items()}
        for p in pkg_specs:
            specs[is_include(p) and p or pkg_name(p)] = p
        self.update_require(list(specs.values()), freeze)


    def remove(self, pkg_specs, freeze=True):
        if not isinstance(pkg_specs, list):
            self.remove([pkg_specs], freeze=freeze)
            return
        dels = set(pkg_name(p) for p in pkg_specs)
        specs = {name: pkg.spec for name, pkg in self.require.pkgs.items()}
        self.update_require([specs[p] for p in specs if p not in dels])


    def update_require(self, req, freeze=True):
        self.cfg['require'] = req
        self.require = XRequired(req)
        dump_json(self.conf_file, self.cfg)
        if freeze:
            self.freeze()


    def freeze(self, deep=False):
        pkgs = [f'{p.name}=={p.version}'
                for p in self.list_installed(deep=deep)]
        write_file(self.freeze_file, pkgs)


    def __str__(self):
        return self._y(tilde_path(str(self.path)))


    def __repr__(self):
        return 'Petal%s(%s)' % (self.is_core and 'Core' or 'Env', self.path)


def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)


def make_dir(path):
    try:
        os.makedirs(path)
    except Exception as e:
        die(f'failed to make env dierctory: {str(e)}')


def check_output(cmd):
    if isinstance(cmd, str):
        cmd = cmd.split()
    return subprocess.check_output(cmd).decode().strip()


def grep(regexp, string, spec=1):
    try:
        mo = re.search(regexp, string)
        if isinstance(spec, list):
            return [mo.group(x) for x in spec]
        else:
            return mo.group(spec)
    except:
        return None


def pkg_name(name):
    return grep(r'^([a-zA-Z0-9_\-]+)', name).lower()


def download_url(url, filename=None, *, timeout=10):
    data = urllib.request.urlopen(url, timeout=timeout).read()
    if filename:
        with open(filename, 'wb+') as f:
            f.write(data)
    return data


def write_file(fname, content=None):
    if isinstance(content, list):
        if content and not content[-1]:
            content = content[:-1]
        write_file(fname, '\n'.join(content))
        return
    with open(fname, 'w+') as f:
        if content:
            f.write(content.strip())
            f.write('\n')


def read_lines(fname):
    "Read lines in file, remove Python comments and empty lines"

    lines = []
    with suppress(Exception):
        with open(fname) as f:
            for line in f:
                line = line.strip()
                if not line or re.match(r'^\s*#', line):
                    continue
                lines.append(line)
    return lines


def dump_json(fname, obj, indent=2):
    with open(fname, 'w+') as f:
        json.dump(obj, f, indent=indent)
        f.write('\n')


def log(*msg):
    line = ''.join([str(x) for x in msg])
    if line:
        print(line)


def os_run(cmd, **env):
    if isinstance(cmd, str):
        cmd = cmd.split()
    if env:
        env_vars = os.environ.copy()
        for key, val in env.items():
            env_vars[key] = str(val)
        return subprocess.call(cmd, env=env_vars)
    else:
        return subprocess.call(cmd)


def is_include(path):
    return re.match(r'^[~/.]', str(path)) is not None


def tilde_path(path):
    home = str(Path('~').expanduser())
    p = str(path)
    return re.sub('^' + home, '~', p) if p.startswith(home) else p


if __name__ == '__main__':
    Petal().run()

### petal ends here
