#!/usr/bin/python3 -B
import sys, os, re, json
from pathlib import Path
from contextlib import suppress, contextmanager

# remove dist-packages, make sure only std libraries are used
sys.path = [p for p in sys.path if not re.search(r'/dist-packages$', p)]


CMD_ALIASES = {'install': 'add', 'remove': 'del', 'uninstall': 'del'}
INSTALL_SPEC_CACHE = 'install-command-spec.json'


def die_usage():
    print("""Usage: petal <command> [args ...]\n
    Create / build / re-build an environment
        petal make [env] [with /usr/bin/python3] [over layer ...]

    Install package(s)
        petal add [pip install params ...] [to env]
        petal install ... (an alias of add)

    Remove package(s)
        petal del [pip uninstall params ...] [from env]
        petal remove ... (an alias of del)
        petal uninstall ... (an alias of del)""")

    sys.exit(1)


class ColorMaker:
    def __init__(self):
        self.istty = sys.stdout.isatty()

    def _color(self, color=0):
        return self.istty and (f'\033[{color}m' if color else '\033[0m') or ''

    def _r(self, txt): return self._color(31) + str(txt) + self._color()
    def _g(self, txt): return self._color(32) + str(txt) + self._color()
    def _y(self, txt): return self._color(33) + str(txt) + self._color()
    def _b(self, txt): return self._color(34) + str(txt) + self._color()
    def _m(self, txt): return self._color(35) + str(txt) + self._color()
    def _c(self, txt): return self._color(36) + str(txt) + self._color()


class Petal(ColorMaker):
    def __init__(self):
        self.exit_code = 0
        # TODO: configurable Python version
        self.python = '/usr/bin/python3.8'
        # TODO: configurable pip URL
        self.pypi = 'https://pypi.tuna.tsinghua.edu.cn'
        super().__init__()

    @property
    def user_site(self):
        return re.sub(r'^.+/(lib.+/site-packages)$', r'\1',
                      check_output(f'{self.python} -m site --user-site'))


    @property
    def py_version(self):
        return check_output([self.python, '-c',
            'import sys; v = sys.version_info; print(f"{v[0]}.{v[1]}")'])


    def run(self):
        args = sys.argv[1:]
        if not args:
            die_usage()
        cmd_name = CMD_ALIASES.get(args[0], args[0])
        cmd = getattr(self, f'cmd_{cmd_name}', None)
        if not cmd:
            die(f'invalid command {cmd_name}')
        cmd(args[1:])
        exit(self.exit_code)


    def cmd_make(self, args):
        env_dir = args[0] if args else 'env'
        if not os.path.exists(env_dir):
            if len(args) > 2:
                if args[1] != 'over' or len(args) < 3:
                    die_usage()
                layers = args[2:]
            else:
                layers = []
            self.env_new(env_dir, layers)
        else:
            if len(args) > 1:
                die_usage()
            self.env_build(env_dir)


    def cmd_show(self, args):
        "Remove pakcages from env"

        env = PetalEnv(args[0]) if len(args) else default_env()
        with open(env.get_file('pkgs')) as f:
            installed = [line.strip() for line in f]
        if not installed:
            die('empty env')

        pkgs = PackageSet(env.list_installed())
        this = str(env.path)
        for spec in installed:
            name = pkg_name(spec)
            pkg = pkgs[name]
            line = spec
            if pkg.env != this:
                line += f' [{tilde_path(pkg.env)}]'
            print(line)
            for p, level in pkgs.walk(name):
                prefix = '  ' * level
                if p.env == this:
                    line = f'- {p.name}'
                else:
                    line = f'* {p.name} [{tilde_path(p.env)}]'
                print(prefix + line)


    def cmd_add(self, args):
        "Install pakcages to env"

        if len(args) > 2 and args[-2] == 'to':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = default_env()

        # get requested packages from command line
        installed_pkgs = env.list_installed(deep=False)
        installed = set(pkg.name for pkg in installed_pkgs)
        install_opts, wanted_pkgs = env.split_install_args(args)
        if not wanted_pkgs:
            die('no package to install')

        # filter out installed packages with version specs removed
        packages = [p for p in wanted_pkgs if pkg_name(p) not in installed]
        if not packages:
            die('all packages installed')

        # run pip to install packages
        install_opts.append('-q')
        cmd = env.pip('install', install_opts + packages)
        log('run ' + self._c(' '.join(cmd)))
        code = os_run(cmd, PETAL_USE_CORE=1)
        if code:
            sys.exit(code)

        env.add(packages)

        log('packages installed to ' + self._y(env.path))


    def cmd_del(self, args):
        "Remove pakcages from env"

        if len(args) > 2 and args[-2] == 'from':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = default_env()

        cmd = env.pip('uninstall', ['-q', '-y'] + args)
        log('run ' + self._c(' '.join(cmd)))
        code = os_run(cmd, PETAL_USE_CORE=1)
        if code:
            sys.exit(code)

        env.remove(packages)

        log('packages removed from ' + self._y(env.path))


    def ensure_core(self):
        env = f'~/.cache/petal.py/core/python{self.py_version}'
        if Path(env).expanduser().exists():
            return env

        error = None
        try:
            self.env_new(env, is_core=True)
        except Exception as e:
            import shutil
            shutil.rmtree(env, ignore_errors=True)
            error = e
        if error:
            raise Error

        return env


    def env_new(self, path, layers=None, *, is_core=False):
        "make a new petal environment"

        if not os.path.exists(self.python):
            die(f'{self.python} not found')
        if layers and not all(map(os.path.exists, layers)):
            die(f'some base layer(s) not found')

        env = Path(path).expanduser()
        if not is_core:
            core = self.ensure_core()
            if not layers:
                layers = [core]
            layers = [self.calc_layer_path(env, layer) for layer in layers]
        make_dir(env / self.user_site)
        make_dir(env / 'bin')
        os.symlink(self.python, env / 'bin' / 'python')
        with open(env / 'pyvenv.cfg', 'w+') as cfg:
            cfg.write(f'home = {os.path.dirname(self.python)}\n')
            cfg.write(f'include-system-site-packages = false\n')
            cfg.write(f'version = {self.py_version}\n')
            if is_core:
                cfg.write(f'core = true\n')
        if is_core:
            self.bootstrap_pip(os.path.realpath(env))
            log(f'petal core for python {self.py_version} made: ',
                self._y(path))
        else:
            msg = 'environment ' + self._y(path) + ' made'
            if layers:
                self.install_layers_hack(env)
                msg += (' on top of [%s]' %
                        ', '.join([self._y(layer) for layer in layers]))
            write_file(env / 'petal.base', layers)
            write_file(env / 'petal.pkgs')
            write_file(env / 'petal.spec')
            write_file(env / '.gitignore', ["*", ".gitignore", "!petal.base",
                                            "!petal.pkgs", "!petal.spec"])
            log(msg)


    def env_build(self, path):
        ...


    def calc_layer_path(self, env, layer):
        if layer.startswith('~'):
            return layer
        if layer.startswith('/'):
            return tilde_path(layer)
        return os.path.relpath(layer, env.resolve())


    def bootstrap_pip(self, env):
        "Download pip wheel package and install it."

        import tempfile

        data = json.loads(download_url(f'{self.pypi}/pypi/pip/json'))
        pip_url = re.sub(r'https?://[^/]*', self.pypi, data['urls'][0]['url'])
        fname = os.path.basename(pip_url)
        pip_ver = fname.split('-')[1]
        with tempfile.TemporaryDirectory(suffix=".petal") as tmp:
            log('download pip ' + self._b(pip_ver) + f' from {self.pypi}')
            py = f'{env}/bin/python'
            whl = f'{tmp}/{fname}'
            download_url(pip_url, whl)
            os_run(f'{py} {whl}/pip install --no-index -q {whl}')
            # cache pip install command spec
            PetalEnv(env)._get_install_spec()
            log('pip bootstrap done for ' + self._y(env))


    def install_layers_hack(self, env):
        "The magic of layered environments."

        site = env / 'lib' / f'python{self.py_version}' / 'site-packages'
        write_file(site / 'petal-layers.pth',
                   "import sys; __import__('_petal_layers').scan_layers()")
        write_file(site / '_petal_layers.py', """
############################ petal layered env hack ############################
import sys, os; from pathlib import Path; from contextlib import suppress
envs = set()
class EnvLayer:
    def __init__(self, root, name):
        # print(root)
        self.is_core = False
        if str(root) in envs:
            self.root = None
        else:
            self.root, self.name = root, name
            envs.add(str(self.root))
    def add_path(self):
        if not self.root:
            return
        layers = []
        with suppress(Exception):
            with open(self.root / 'pyvenv.cfg') as cfg:
                for line in [x.strip() for x in cfg]:
                    if line.startswith('#'):
                        continue
                    key, val = [x.strip() for x in line.split('=')]
                    if key == 'core' and val.lower() == 'true':
                        self.is_core = True
        if not self.is_core:
            with suppress(Exception):
                with open(self.root / 'petal.base') as base:
                    for d in [x.strip() for x in base]:
                        layer = d[0] in ['/', '~'] and Path(d) or self.root / d
                        layer = layer.expanduser().resolve()
                        if layer.is_dir(): layers.append(layer)
        if not self.is_core or 'PETAL_USE_CORE' in os.environ:
            site_path = self.root / 'lib' / self.name / 'site-packages'
            if site_path.is_dir():
                path = str(site_path)
                if path not in sys.path:
                    sys.path.append(path)
        with suppress(Exception):
            for layer in layers: EnvLayer(layer, self.name).add_path()
def scan_layers():
    py_dir = Path(__file__).parent.parent
    EnvLayer(py_dir.parent.parent, py_dir.name).add_path(); envs = set()
################################################################################
""")


class Package:
    def __init__(self, pkg):
        self.name = pkg.project_name
        self.env = grep(r'^(.+)/lib/python.+/site-packages', pkg.module_path)
        self.version = pkg.version
        self.deps = [x.project_name for x in pkg.requires()]

    def __str__(self): return self.name
    def __hash__(self): return hash(self.name)
    def __eq__(self, rhs): return self.name == rhs.name


class PackageSet:
    def __init__(self, pkgs):
        self.pkgs = {p.name: p for p in pkgs}

    def __getitem__(self, key):
        return self.pkgs[key]

    def walk(self, name, level=0):
        "depth first recursive walk"
        pkg = self.pkgs[name]
        for dep in pkg.deps:
            yield (self.pkgs[dep], level + 1)
            yield from self.walk(dep, level + 1)


class PetalEnv:
    def __init__(self, path):
        self.path = Path(path).expanduser().resolve()
        env_cfg = self.path / 'pyvenv.cfg'
        if not env_cfg.is_file():
            die(f'invalid env {path}')
        self.is_core = False
        self.bases = []
        self.py_version = None
        with open(env_cfg) as cfg:
            for line in cfg.readlines():
                line = line.strip()
                if line.startswith('#'):
                    continue
                key, val = [x.strip() for x in line.split('=')]
                if key == 'core' and val.lower() == 'true':
                    self.is_core = True
                    self.bases = []
                    break
                if key == 'version':
                    self.py_version = val
        with suppress(Exception):
            with open(self.get_file('base')) as base:
                for d in [x.strip() for x in base]:
                    layer = d[0] in ['/', '~'] and Path(d) or self.path / d
                    layer = layer.expanduser().resolve()
                    if layer.is_dir():
                        self.bases.append(layer)
        if self.py_version is None:
            die(f'Python version not found in {env_cfg}')


    def get_file(self, suffix):
        return self.path / f'petal.{suffix}'


    @property
    def layers(self):
        "Iterate all direct base layers"
        for p in self.bases:
            yield PetalEnv(p)

    @property
    def core(self):
        "Find core env recursively"
        if self.is_core:
            return self
        for e in self.layers:
            # we don't need to loop through all layers
            return e.core
        die('core env not found')


    def pip(self, cmd, args):
        "Return pip command line as a string list"
        ret = [str(self.path / 'bin' / 'python'), '-m' , 'pip', cmd]
        if isinstance(args, list):
            ret += args
        else:
            ret += args.split()
        return ret


    @property
    def site_path(self):
        "Site Path of this env"
        return self.path / 'lib' / f'python{self.py_version}' / 'site-packages'


    def paths(self, include_core=True):
        "Site Paths of this env and all base envs"
        if include_core or not self.is_core:
            ret = [str(self.site_path)]
        else:
            ret = []
        for e in self.layers:
            ret += e.paths(include_core)
        return ret


    @contextmanager
    def tapped(self):
        orig_path = sys.path
        try:
            sys.path = list(reversed(self.paths())) + sys.path
            yield
        finally:
            sys.path = orig_path


    def list_installed(self, deep=True):
        search_paths = self.paths(include_core=False)
        pkgs = []
        with self.core.tapped():
            from pip._internal.metadata import pkg_resources
            e = pkg_resources.Environment.from_paths(search_paths)
            dists = e.iter_installed_distributions()
            pkgs = [Package(d._dist) for d in dists]
        if deep:
            return pkgs
        return [p for p in pkgs if p.env == str(self.path)]


    def split_install_args(self, args):
        "Split args into pip install options and package names"
        ins_spec = self._get_install_spec()
        idx = set()
        for i in range(len(args)):
            if args[i].startswith('-'):
                idx.add(i)
                if args[i] in ins_spec and i + 1 < len(args):
                    idx.add(i + 1)
        opts, pkgs = [], []
        for i in range(len(args)):
            if i in idx:
                opts.append(args[i])
            else:
                pkgs.append(args[i])
        return (opts, pkgs)


    # We need to extract package names from command line, but in theory all pip
    # install options should be supported.  The solution we use is to extract
    # and cache command line switches from `pip install --help` and use those
    # to filter out options.
    def _get_install_spec(self):
        "Return pip install command-line spec of current version of pip"

        cache_fname = self.core.path / INSTALL_SPEC_CACHE
        if not cache_fname.exists():
            write_file(cache_fname, '{}')
        with open(cache_fname) as f:
            cache = json.load(f)
        pip_ver = self._get_pip_version()
        if not pip_ver:
            die(f'failed to get pip version in core env {self.core.path}')
        if pip_ver in cache:
            return cache[pip_ver]

        spec = []
        pip_cmd = self.core.pip('install', '--help')
        for line in check_output(pip_cmd).split('\n'):
            # this regexp filters out all options with argument
            if re.match('^\s{2,4}-[^ ].+\s+<[^ ]+>', line):
                spec += [x for x in line.split() if x.startswith('-')]
        spec = sorted(spec)

        # cache the result
        cache[pip_ver] = spec
        with open(cache_fname, 'w+') as f:
            json.dump(cache, f, indent=2)

        return spec


    def _get_pip_version(self):
        "Look up pip version in core env"
        if self.core is None:
            die(f'core env not found for {self.path}')
        for d in self.core.site_path.iterdir():
            if d.is_dir():
                version = grep(r'^pip-(.+)\.dist-info$', d.name)
                if version:
                    return version
        return None


    def add(self, pkg_specs):
        pkgs = read_packages(self.get_file('pkgs'))
        for pkg in pkg_specs:
            if pkg_name(pkg) not in pkgs:
                pkgs.append(pkg)
        if pkgs:
            write_file(self.get_file('pkgs'), '\n'.join(sorted(pkgs)))
        self.freeze()


    def remove(self, pkg_specs):
        ...


    def freeze(self, deep=False):
        pkgs = [f'{p.name}=={p.version}'
                for p in self.list_installed(deep=deep)]
        write_file(self.get_file('spec'), pkgs)


    def __str__(self):
        return 'Petal%s(%s)' % (self.is_core and 'Core' or 'Env', self.path)


def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)


def make_dir(path):
    try:
        os.makedirs(path)
    except Exception as e:
        die(f'failed to make env dierctory: {str(e)}')


def check_output(cmd):
    import subprocess
    if isinstance(cmd, str):
        cmd = cmd.split()
    return subprocess.check_output(cmd).decode().strip()


def grep(regexp, string, spec=1):
    try:
        mo = re.search(regexp, string)
        if isinstance(spec, list):
            return [mo.group(x) for x in spec]
        else:
            return mo.group(spec)
    except:
        return None


def pkg_name(name):
    return grep(r'^([a-zA-Z0-9_\-]+)', name)


def download_url(url, filename=None, *, timeout=10):
    import urllib.request
    data = urllib.request.urlopen(url, timeout=timeout).read()
    if filename:
        with open(filename, 'wb+') as f:
            f.write(data)
    return data


def write_file(fname, content=None):
    if isinstance(content, list):
        write_file(fname, '\n'.join(content))
        return
    with open(fname, 'w+') as f:
        if content:
            f.write(content.strip())
            f.write('\n')


def read_packages(fname):
    try:
        with open(fname) as f:
            return [line for line in [x.strip() for x in f.readlines()]
                    if not line.startswith('#')]
    except:
        return []


def log(*msg):
    print(''.join([str(x) for x in msg]))


def default_env():
    envs = [d for d in Path(os.getcwd()).iterdir()
            if d.is_dir() and (d / 'pyvenv.cfg').exists()]
    if not envs:
        die('No env found!')
    if len(envs) > 1:
        die('Multiple envs found, you need to choose one explicitly')
    return PetalEnv(envs[0])


def os_run(cmd, **env):
    import subprocess
    if isinstance(cmd, str):
        cmd = cmd.split()
    if env:
        env_vars = os.environ.copy()
        for key, val in env.items():
            env_vars[key] = str(val)
        return subprocess.call(cmd, env=env_vars)
    else:
        return subprocess.call(cmd)

def tilde_path(path):
    home = str(Path('~').expanduser())
    return re.sub('^' + home, '~', path) if path.startswith(home) else path

# class PkgTree:
#     def __init__(self):
#         self.pkgs = defaultdict(set)

#     def scan(self, path):
#         try:
#             from pip._internal.metadata import pkg_resources
#             env = pkg_resources.Environment.from_paths(path)
#             return [d._dist for d in
#                     env.iter_installed_distributions(user_only=False)]
#         except ImportError:
#             from pip._internal.utils import misc
#             return misc.get_installed_distributions(user_only=True)

if __name__ == '__main__':
    # print(list_packages('/usr/local/lib/python3.8/dist-packages'))
    Petal().run()

### petal ends here
