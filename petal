#!/usr/bin/python3 -B

import os
import re
import sys
import json
import time
import shutil
import asyncio
import tempfile
import subprocess
import urllib.request
from pathlib import Path
from collections import defaultdict
from contextlib import suppress, contextmanager


# exclude dist-packages, make sure only std libraries are used
sys.path = [p for p in sys.path if not re.search(r'/dist-packages$', p)]

INSTALL_SPEC_CACHE = 'install-command-spec.json'

CMD_ALIASES  = {'install':   'add',
                'remove':    'del',
                'uninstall': 'del',
                'copy':      'deliver',
               }

PYPI_SOURCES = ['pypi.org',
                'pypi.doubanio.com',
                'pypi.tuna.tsinghua.edu.cn',
               ]


def die_usage():
    print("""
Usage: petal <command> [args ...]\n
    Environment creation, recovery, and synchronization
       petal make [env] [with /usr/bin/python3] [over|on base_env ...]

    Environment inspection
       petal show [options] [env]
             -a, --all       show all packages (non-explicits)
             -v, --version   show package version

    Environment clean up
       petal clean <env>

    Environment delivery
       petal deliver <env> [to] <destination>

    Package install
       petal add <pip install params ...> [to env]

    Package removal
       petal del <package> ... [from env]

    Package upgrade
       petal upgrade [options] <package ... | all | pip> [in env]
             -e, --eager     upgrade dependencies to latest possible version.

    Package action plan
       petal plan add | del | upgrade ... [on env]

    Command aliases
       +--------------+--------------+
       | alias        | command      |
       +--------------+--------------+
       | install      | add          |
       | uninstall    | del          |
       | remove       | del          |
       | copy         | deliver      |
       +--------------+--------------+
""".strip())
    sys.exit(1)


class ColorMaker:
    def __init__(self):
        self.istty = sys.stdout.isatty()


    def _color(self, color=0):
        return self.istty and (f'\033[{color}m' if color else '\033[0m') or ''


    def _r(self, txt): return self._color(31) + str(txt) + self._color()
    def _g(self, txt): return self._color(32) + str(txt) + self._color()
    def _y(self, txt): return self._color(33) + str(txt) + self._color()
    def _b(self, txt): return self._color(34) + str(txt) + self._color()
    def _m(self, txt): return self._color(35) + str(txt) + self._color()
    def _c(self, txt): return self._color(36) + str(txt) + self._color()


class Petal(ColorMaker):
    def __init__(self):
        super().__init__()
        self.exit_code = 0
        self.python = os.path.realpath(sys.executable)


    def run(self):
        "Entry function of petal."

        args = sys.argv[1:]
        if not args:
            die_usage()
        cmd_name = CMD_ALIASES.get(args[0], args[0])
        cmd = getattr(self, f'cmd_{cmd_name}', None)
        if not cmd:
            die(f'invalid command {cmd_name}')
        cmd(args[1:])
        exit(self.exit_code)


    def _get_python(self, args):
        "Parse 'with' clause for python executable; Return remaining args."

        if not args or 'with' not in args:
            return args
        idx = args.index('with') + 1
        if idx >= len(args):
            die_usage()
        self.python = args[idx]
        if not os.path.exists(self.python):
            die(f'{self.python} not found!')
        self.python = os.path.realpath(self.python)
        args[idx] = ''
        args[idx-1] = ''
        return list(filter(None, args))


    def cmd_make(self, args):
        "Make or recover env."

        if args:
            args = self._get_python(args)
        if args:
            env_dir = args[0]
            args = args[1:]
        else:
            env_dir = 'env'
        if not os.path.exists(env_dir):
            if len(args) > 1 and args[0] in ['over', 'on']:
                layers = args[1:]
            elif len(args):
                die_usage()
            else:
                layers = []
            self.env_new(env_dir, layers)
        else:
            if len(args) > 1:
                die_usage()
            env_ready = True
            try:
                env = PetalEnv(env_dir)
            except:
                env_ready = False
            if not env_ready:
                self.env_build(env_dir, restore=True)
            self.env_restore(env_dir, restore=True)


    def cmd_clean(self, args):
        "Clean up env."

        if len(args) != 1:
            die_usage()
        env_dir = Path(args[0])

        # delete everything except git ignored
        git_ignored = read_lines(env_dir / '.gitignore')
        excluded = set(x[1:] for x in git_ignored if x.startswith('!'))
        items = [d for d in env_dir.iterdir() if d.name not in excluded]
        if not items:
            log(f'{self._env(env_dir)} seems cleaned already')
            return
        for item in items:
            if item.is_dir():
                shutil.rmtree(item, ignore_errors=True)
            else:
                os.unlink(item)
        log(f'{self._env(env_dir)} cleaned up')


    def cmd_deliver(self, args):
        "Copy env with packages in all base env(s) to a new directory."

        # parse args
        if len(args) == 3:
            if args[1] != 'to':
                die_usage()
            src_path, dst_path = args[0], args[2]
        elif len(args) == 2:
            src_path, dst_path = args
        else:
            die_usage()

        # resolve correct source and destination
        src = PetalEnv(src_path)
        dst = Path(dst_path)
        if dst.exists():
            if not dst.is_dir():
                die(f'{dst} found but not a directory')
            dst = dst / src.path.name
            if dst.exists():
                die(f'{dst} already exists')

        # create an empty env
        self._ensure_core()
        self.create_pep405(dst, python=(src.path / 'bin' / 'python').resolve())

        # copy packages bottom-up from src and its bases to dst env
        for env in reversed(list(src.walk())):
            env.copy_packages(dst)

        log(f'deliver {self._env(src)} ==> {self._url(dst)}')


    def cmd_show(self, args):
        "List installed packages."

        opts = [x for x in args if x.startswith('-')]
        args = [x for x in args if not x.startswith('-')]
        show_version = '-v' in opts or '--version' in opts
        show_all = '-a' in opts or '--all' in opts

        # find the env we're working on
        env = PetalEnv(args[0]) if len(args) else self.default_env

        def _pkg_line(p, level, sign='-'):
            prefix = '  ' * level
            name = p.disp
            if show_version:
                name += f' {self._ver(p.version)}'
            return f'{prefix}{sign} {name}'

        explicits = env.explicits(deep=True)
        if not explicits:
            die('empty env')

        pkgs = PackageSet(env)
        log(f'packages in {self._env(env)}:')
        for xpkg in explicits:
            name = xpkg.name
            pkg = pkgs[name]
            line = f'- {self._pkg(xpkg.spec)}'
            if show_version:
                line += f' {self._ver(pkg.version)}'
            if not pkg.native:
                relpath = os.path.relpath(pkg.env, env.path)
                line += f' from {self._env(relpath)}'
            log(line)
            if show_all:
                for p, level in pkgs.walk(name):
                    log(_pkg_line(p, level))

        explicit_names = set(p.name for p in explicits)
        orphans = [p for p in pkgs.orphans()
                   if p.native and p.name not in explicit_names]
        if orphans:
            log('- (orphans)')
            for p in orphans:
                log(_pkg_line(p, 1, '?'))


    def cmd_add(self, args, dryrun=False):
        "Install pakcages to env."

        # find the env we're working on
        if len(args) > 2 and args[-2] == 'to':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = self.default_env

        if not args:
            die_usage()

        # install to a naive env
        if env.is_naive:
            self._ensure_core(env.py_version)
            pip_cmd = env.pip('install', args)
            env_vars = {'PYTHONPATH': str(env.core.site_path)}
            self._run_pip(pip_cmd, dry=dryrun, env=env_vars)
            return

        # get requested packages from command line
        pip_opts, wanted_specs = env.split_install_args(args)
        wanted = Explicits(wanted_specs)
        if not wanted:
            die('no package to install')

        # filter out installed packages with version specs removed
        installed = set(pkg.name for pkg in env.list_installed(deep=False))
        new = [p for p in wanted.names if p not in installed]

        # handle promotion: package installed but not in the explicit set
        if not new:
            explicits = set(p.name for p in env.explicits())
            selected = [p for p in wanted.names if p not in explicits]
            if selected:
                if dryrun:
                    log(f'[{env}] plan to promote {self._pkg(selected)}')
                else:
                    env.add(selected, freeze=False)
                    log(f'[{env}] promote {self._pkg(selected)} as explicit')
            else:
                log(dryrun and 'nothing in plan' or 'nothing to change')
            return

        # run pip to install packages
        install_specs = wanted.filter(new).specs
        pip_cmd = env.pip('install', pip_opts + install_specs)
        self._run_pip(pip_cmd, dry=dryrun)
        if dryrun:
            return

        if '--dry-run' not in pip_opts:
            env.add(wanted.lines)
            log(f'[{env}] packages installed: {self._pkg(install_specs)}')


    def cmd_del(self, args, dryrun=False):
        "Remove pakcages from env."

        # find the env we're working on
        if len(args) > 2 and args[-2] == 'from':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = self.default_env

        if not args:
            die_usage()

        # installed packages set
        iset = PackageSet(env)
        explicits = env.explicits()
        installed = set(p.name for p in explicits)

        # find collateral packages (dependencies) to remove
        wanted = [p.lower() for p in args]
        unknwon = [p for p in wanted if p not in iset]
        if unknwon:
            warn = self._r('unknown packages')
            die(f'[{env}] {warn}: {self._pkg(unknwon)}')

        # allow delisting packages without uninstalling them
        wanted_set = set(wanted)
        uninstall = [p for p in wanted if not iset[p].depby - wanted_set]
        delist = [p for p in wanted if p not in uninstall]

        msg = ''
        if uninstall:
            collaterals = set()
            for name in uninstall:
                if not name in iset:
                    die(f'package {self._pkg(name)} not found in {env}')
                collaterals.update(p for p in iset.dep_on(name))
            removing = set(iset[p] for p in uninstall) | collaterals
            orphans = [p.name for p in collaterals # a package is orphaned if:
                       # it's native (never remove packages in base envs), and
                       if p.native
                       # not in explicit set, and
                       and p.name not in installed
                       # not needed by any other remaining packages
                       and not set(iset.dep_by(p.name)) - removing]
            cmd = env.pip('uninstall', ['--yes'] + uninstall + orphans)
            if not dryrun:
                self._run_pip(cmd)
                msg += f'[{env}] uninstalled: {self._pkg(uninstall)}'
            else:
                msg += f'[{env}] plan to uninstall: {self._pkg(uninstall)}'
            if orphans:
                msg += f', with dependencies: {self._pkg(orphans)}'

        real_delist = [p for p in delist if p in installed]
        if real_delist:
            delist = real_delist
            if msg:
                msg += '\n'
            if dryrun:
                msg += f'[{env}] plan to delist {self._pkg(delist)}'
            else:
                msg += f'[{env}] delist {self._pkg(delist)} from explicits'
        elif not dryrun and delist:
            msg += f'[{env}] ignore {self._pkg(delist)}'

        wanted = uninstall + delist
        if wanted:
            if dryrun:
                log(msg or 'nothing in plan')
            else:
                env.remove(wanted)
                log(msg)
        else:
            log('nothing to change')


    def cmd_upgrade(self, args, dryrun=False):
        "Upgrade packages."

        opts = [x for x in args if x.startswith('-')]
        args = [x for x in args if not x.startswith('-')]
        eager = '-e' in opts or '--eager' in opts

        # find the env we're working on
        if len(args) > 2 and args[-2] == 'in':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = self.default_env

        specs = args
        upgrade_opts = eager and ['-U', '--upgrade-strategy=eager'] or ['-U']
        if specs == ['pip']:
            pip_cmd = env.core.pip('install', upgrade_opts + ['pip'])
        else:
            if not specs or specs == ['all']:
                specs = env.require.specs
            for s in specs:
                specs = [env.require[s].spec for s in specs if s in env.require]
            if not specs:
                log('nothing to upgrade')
                return
            pip_cmd = env.pip('install', upgrade_opts + specs)
        self._run_pip(pip_cmd, dry=dryrun)

        if not dryrun:
            env.freeze()


    def cmd_plan(self, args):
        "Print action plans."

        if len(args) < 1:
            die_usage()
        cmd = CMD_ALIASES.get(args[0], args[0])
        args = args[1:]
        if cmd == 'add':
            if len(args) > 2 and args[-2] == 'on':
                args[-2] = 'to'
            self.cmd_add(args, dryrun=True)
        elif cmd == 'del':
            if len(args) > 2 and args[-2] == 'on':
                args[-2] = 'from'
            self.cmd_del(args, dryrun=True)
        elif cmd == 'upgrade':
            if len(args) > 2 and args[-2] == 'in':
                args[-2] = 'in'
            self.cmd_upgrade(args, dryrun=True)
        else:
            die_usage()


    def env_new(self, path, layers=[], *, is_core=False):
        "Make a new petal environment."

        if not os.path.exists(self.python):
            die(f'{self.python} not found')
        for layer in layers:
            self._ensure_layer(layer)

        # calculate base layers' paths
        env = Path(path).expanduser()
        based_on_core = False
        if not is_core:
            core = self._ensure_core()
            if not layers:
                layers = [core]
                based_on_core = True
            layers = [self.calc_layer_path(env, layer) for layer in layers]

        # make PEP-405 virtual env
        self.create_pep405(env)

        # bootstrap pip for core env
        if is_core:
            self.bootstrap_pip(os.path.realpath(env))
            log(f'petal core (python{self.py_version}) made: {self._url(path)}')
            return

        # write files for petal env
        conf_layers = [] if based_on_core else layers
        dump_json(env / 'petal.json', {'python': self.py_version,
                                       'bases': conf_layers,
                                       'require': []})
        write_file(env / 'petal.freeze')
        write_file(env / '.gitignore',
                   ["*", "!.gitignore", "!petal.json", "!petal.freeze"])

        msg = f'environment {self._env(path)} made'
        if layers:
            self.install_layers_hack(env)
            msg += f' on top of [{self._env(layers)}]'
        msg += f' with {self._c(self.python)}'

        log(msg)


    def env_build(self, path, *, restore=False):
        "Build a petal environment from existing specs."

        env = Path(path)
        if not env.is_dir():
            die(f'{path} is not a directory')

        # check Python version
        with open(env / 'petal.json') as f:
            cfg = json.load(f)
        env_py = cfg['python']
        if env_py != self.py_version:
            die(f'{path} uses Python {env_py}')

        freeze = env / 'petal.freeze'
        if not freeze.exists():
            die(f'{str(freeze)} not found!')

        if not cfg.get('bases', []):
            self._ensure_core()

        # create it
        for f in ['pyvenv.cfg', 'bin', 'lib']:
            if (env / f).exists():
                env = env.resolve()
                log(f'{self._env(env)} seems ready')
                return

        self.create_pep405(env)
        self.install_layers_hack(env)
        act = restore and 'rebuilt' or 'made'
        log(f'environment {self._env(env)} {act} with {self._c(self.python)}')


    def env_restore(self, path, *, restore=False):
        "Restore packages in a petal environment."

        env = isinstance(path, PetalEnv) and path or PetalEnv(path)
        freeze = env.path / 'petal.freeze'
        if not freeze.exists():
            die(f'{freeze} not found!')

        freeze_empty = os.stat(freeze).st_size == 0
        if freeze_empty:
            if not restore:
                log(f'{freeze} seems empty')
            return

        lib_empty = not any(True for p in env.site_path.iterdir())
        if not lib_empty:
            # check if it's different from freeze file
            installed = sorted([f'{p.name}=={p.version}'
                                for p in env.list_installed()])
            freezed = sorted(read_lines(freeze))
            if installed == freezed:
                log(f'{self._env(env)} seems up-to-date')
                return

        self._run_pip(env.pip('install', ['-r', str(freeze.resolve())]))


    def _ensure_core(self, version=None):
        "Return core env.  Make it if necessary."

        if not version:
            version = self.py_version
        env = f'~/.cache/petal.py/core/python{version}'
        if Path(env).expanduser().exists():
            return env

        error = None
        try:
            self.env_new(env, is_core=True)
        except Exception as e:
            shutil.rmtree(env, ignore_errors=True)
            error = e
        if error:
            raise error

        return env


    def _ensure_layer(self, layer):
        if not os.path.exists(layer):
            die(f'layer {layer} not found')
        env = PetalEnv(layer)
        if env.py_version != self.py_version:
            path = tilde_path(os.path.realpath(layer))
            die(f'{path} uses python{env.py_version}, need {self.py_version}')


    def _pkg(self, pkgs):
        "Package display helper."

        if isinstance(pkgs, list):
            return ', '.join(self._g(p) for p in pkgs)
        return self._g(pkgs)


    def _env(self, envs):
        "Environment display helper."

        if isinstance(envs, list):
            return ', '.join(self._url(p) for p in envs)
        return self._y(tilde_path(envs))


    def _url(self, envs):
        "Path and URL display helper."

        if isinstance(envs, list):
            return ', '.join(self._url(p) for p in envs)
        return self._m(tilde_path(envs))


    def _ver(self, version):
        return self._b(str(version))


    def _run_pip(self, cmd, dry=False, *, env=None):
        "Run pip command in child process."

        if not env:
            env = {'PETAL_USE_CORE': '1'}
        env_str = ' '.join(f'{key}={val}' for key, val in env.items())
        log(self._url(f'{env_str} ' + ' '.join(tilde_path(x) for x in cmd)))
        if dry:
            return
        code = os_run(cmd, **env)
        if code:
            sys.exit(code)


    def create_pep405(self, env, *, python=None):
        "Make a bare PEP-405 virtual environment."

        make_dir(env / 'bin')
        os.symlink(python or self.python, env / 'bin' / 'python')
        make_dir(env / self.user_site)
        write_file(env / 'pyvenv.cfg',
                   [f'home = {os.path.dirname(self.python)}',
                    f'include-system-site-packages = false'])


    def calc_layer_path(self, env, layer):
        "Calculate relative path of base layer."

        if layer.startswith('~'):
            return layer
        if layer.startswith('/'):
            return tilde_path(layer)
        return os.path.relpath(layer, env.resolve())


    def bootstrap_pip(self, env, pypi=None):
        "Download pip wheel package and install it."

        pypi = self.get_pypi_url()

        try:
            data = json.loads(download_url(f'{pypi}/pypi/pip/json'))
            pip_url = re.sub(r'https?://[^/]*', pypi, data['urls'][0]['url'])
            fname = os.path.basename(pip_url)
            pip_ver = fname.split('-')[1]
            with tempfile.TemporaryDirectory(suffix=".petal") as tmp:
                log(f'download pip {self._ver(pip_ver)} from {self._url(pypi)}')
                py = f'{env}/bin/python'
                whl = f'{tmp}/{fname}'
                opts = f'-q --no-index --no-warn-script-location'
                download_url(pip_url, whl)
                os_run(f'{py} {whl}/pip install {opts} {whl}')
        except Exception as e:
            shutil.rmtree(env, ignore_errors=True)
            raise
        # cache pip install command spec
        PetalEnv(env)._get_install_spec()
        log(f'pip bootstrap done for {self._env(env)}')


    def get_pypi_url(self):
        url = os.environ.get('PYPI', PYPI_SOURCES)
        if isinstance(url, list):
            ping = {host: ms for host, ms in tcp_ping(url, 443).items() if ms}
            if not ping:
                raise ValueError('No valid PyPI host found!')
            url = next(iter(ping.keys()))
        return '://' in url and url or 'https://' + url


    def install_layers_hack(self, env):
        "The magic of layered environments."

        site = env / 'lib' / f'python{self.py_version}' / 'site-packages'
        write_file(site / 'petal-layers.pth',
                   "import sys; __import__('_petal_layers').scan_layers()")
        write_file(site / '_petal_layers.py', """
############################ petal layered env hack ############################
import sys, os, json; from pathlib import Path; from contextlib import suppress
envs = set() # mutual inclusion prevention
def scan_layers(root=None):
    global envs
    if root is None:
        scan_layers(Path(__file__).parent.parent.parent.parent)
        envs = set()
        return
    if root in envs:
        return
    envs.add(str(root))
    with suppress(Exception):
        json_conf = root / 'petal.json'
        not_core = json_conf.exists()
        layers = []
        py_version = '.'.join(str(v) for v in sys.version_info[:2])
        libdir = f'python{py_version}'
        if not_core:
            with open(json_conf) as f:
                conf = json.load(f)
            if 'python' not in conf or conf['python'] != py_version:
                return
            bases = conf['bases'] or [f'~/.cache/petal.py/core/{libdir}']
            for d in bases:
                layer = d[0] in ['/', '~'] and Path(d) or root / d
                layer = layer.expanduser().resolve()
                if layer.is_dir():
                    layers.append(layer)
        if not_core or 'PETAL_USE_CORE' in os.environ:
            site_path = root / 'lib' / libdir / 'site-packages'
            if site_path.is_dir():
                path = str(site_path)
                if path not in sys.path:
                    sys.path.append(path)
        for layer in layers: scan_layers(layer)
################################################################################
""")


    @property
    def py_version(self):
        "Version of the env's (NOT this script's) Python."

        return check_output([self.python, '-c',
            'import sys; v = sys.version_info; print(f"{v[0]}.{v[1]}")'])


    @property
    def user_site(self):
        return f'lib/python{self.py_version}/site-packages'


    @property
    def default_env(self):
        envs = [d for d in Path(os.getcwd()).iterdir()
                if d.is_dir() and (d / 'pyvenv.cfg').exists()]
        if not envs:
            die('No env found!')
        if len(envs) > 1:
            die(f'Multiple envs found, you need to choose one from:'
                f' {self._env(envs)}')
        return PetalEnv(envs[0])


class Package:
    "Abstraction of single package."

    def __init__(self, pkg, extras=[]):
        self.disp = pkg.project_name
        self.name = pkg_name(self.disp)
        self.extras = extras
        self.env = grep(r'^(.+)/lib/python.+/site-packages', pkg.module_path)
        self.native = True
        self.version = pkg.version
        self.depon = [pkg_name(x.name) for x in pkg.requires(extras=extras)]
        self.depby = set()
    def __str__(self): return self.disp
    def __repr__(self): return f'Package({self.disp})'
    def __hash__(self): return hash(self.name)
    def __eq__(self, rhs): return self.name == rhs.name
    def __lt__(self, rhs): return self.name < rhs.name


class PackageSet:
    "A set of packages with dependency traversing."

    def __init__(self, env, deep=True):
        self.pkgs = {p.name: p for p in env.list_installed(deep=deep)}
        # resolve dependency network
        this_env = str(env.path)
        for name, pkg in self.pkgs.items():
            pkg.native = pkg.env == this_env
            for dep in pkg.depon:
                if dep in self.pkgs:
                    self.pkgs[dep].depby.add(name)

    def __getitem__(self, key):
        return self.pkgs[key.lower()]

    def __contains__(self, key):
        return key.lower() in self.pkgs

    def walk(self, name, level=0):
        "Depth-first recursive walk."
        pkg = self.pkgs[name]
        for dep in pkg.depon:
            yield (self.pkgs[dep], level + 1)
            yield from self.walk(dep, level + 1)

    def dep_on(self, name):
        "Get all dependencies."
        pkg = self.pkgs[name]
        for dep in pkg.depon:
            yield self.pkgs[dep]
            yield from self.dep_on(dep)

    def dep_by(self, name):
        "Get all reverse dependencies."
        pkg = self.pkgs[name]
        for dep in pkg.depby:
            yield self.pkgs[dep]
            yield from self.dep_by(dep)

    def orphans(self):
        return sorted([pkg for pkg in self.pkgs.values() if not pkg.depby])


class XPackage:
    "Explicit package."

    def __init__(self, spec):
        self._spec = spec


    @property
    def name(self):
        return pkg_name(self._spec)


    @property
    def spec(self):
        return self._spec


    def __str__(self): return self._spec
    def __repr__(self): return self._spec


class Explicits:
    "Explicitly required packages."

    def __init__(self, specs=[], *, pwd=None):
        self.lines = []
        self.pkgs = {}
        self.pwd = pwd or Path(os.getcwd())
        for spec in specs:
            if not isinstance(spec, str) or not spec:
                continue
            self.lines.append(spec)
            name = pkg_name(spec)
            if name not in self.pkgs:
                self.pkgs[name] = XPackage(spec)


    def __bool__(self):
        return bool(self.pkgs)


    def __contains__(self, pkg):
        return pkg in self.pkgs


    def __getitem__(self, pkg):
        return self.pkgs[pkg]


    @property
    def names(self):
        return list(self.pkgs.keys())


    @property
    def specs(self):
        return [x.spec for x in self.pkgs.values()]


    @property
    def lut(self):
        return {name: pkg.spec for name, pkg in self.pkgs.items()}


    @property
    def full(self):
        return list(self.pkgs.values())


    def filter(self, names):
        self.lines = [line for line in self.lines if pkg_name(line) in names]
        self.pkgs = {k: v for k, v in self.pkgs.items() if k in names}
        return self


class PetalEnv(ColorMaker):
    "Abstraction of Petal Environment."

    def __init__(self, path):
        super().__init__()
        self.path = Path(path).expanduser().resolve()
        env_str = self._y(tilde_path(path))
        if not (self.path / 'pyvenv.cfg').is_file():
            raise RuntimeError(f'Invalid env {env_str}')
        for d in ['bin', 'lib']:
            if not (self.path / d).is_dir():
                raise FileNotFoundError(f'Broken env {env_str}: {d} not found')
        self.cfg = {}
        with suppress(FileNotFoundError):
            with open(self.path / 'petal.json') as f:
                self.cfg = json.load(f)
        self.is_core = False
        self.is_naive = False
        self.bases = []
        bases = []
        if self.cfg:
            self.py_version = self.cfg['python']
            self.require = Explicits(self.cfg['require'], pwd=self.path.parent)
            bases = self.cfg.get('bases', [])
        else:
            self.require = Explicits(pwd=self.path.parent)
            if (self.path / INSTALL_SPEC_CACHE).exists():
                self.is_core = True
                self.py_version = grep(r'^python(\d.+)$', self.path.name)
            else:
                self.is_naive = True
                self.py_version = check_output(
                    [f'{str(self.path)}/bin/python', '-c',
                     'import sys; v = sys.version_info;'
                     ' print(f"{v[0]}.{v[1]}")'])
        if not self.py_version:
            die(f'Python version not found in {self.path}')

        if self.is_core or self.is_naive:
            return

        if not bases:
            bases = [f'~/.cache/petal.py/core/python{self.py_version}']
        for d in bases:
            layer = d[0] in ['/', '~'] and Path(d) or self.path / d
            layer = layer.expanduser().resolve()
            if layer.is_dir():
                self.bases.append(layer)


    @property
    def conf_file(self):
        return self.path / f'petal.json'


    @property
    def freeze_file(self):
        return self.path / f'petal.freeze'


    @property
    def layers(self):
        "Iterate through all direct base layers."
        for p in self.bases:
            yield PetalEnv(p)


    @property
    def core(self):
        if self.is_core:
            return self
        core_path = f'~/.cache/petal.py/core/python{self.py_version}'
        if not Path(core_path).expanduser().is_dir():
            raise RuntimeError(f'core env {core_path} not found')
        return PetalEnv(core_path)


    @property
    def site_path(self):
        "Site path of this env."
        return self.path / 'lib' / f'python{self.py_version}' / 'site-packages'


    def copy_packages(self, dst):
        "Copy site-packages."

        if isinstance(dst, PetalEnv):
            dst = dst.site_path
        else:
            dst = Path(dst)
            if (dst / 'pyvenv.cfg').exists():
                dst = next(iter((dst / 'lib').iterdir())) / 'site-packages'
        shutil.copytree(self.site_path, dst,
                        ignore=shutil.ignore_patterns('_petal*.*',
                                                      'petal*.pth'),
                        dirs_exist_ok=True)


    def explicits(self, deep=False):
        "Explicit packages."

        pkgs = self.require.full
        if deep:
            for layer in self.layers:
                pkgs += layer.explicits(deep=True)
        return pkgs


    def paths(self, include_core=True):
        "Site paths of this env and all base envs."

        if include_core or not self.is_core:
            ret = [str(self.site_path)]
        else:
            ret = []
        for e in self.layers:
            ret += e.paths(include_core)
        return ret


    def walk(self, *, include_core=False):
        "A generator to walk down all layers."

        if self.is_core and not include_core:
            return

        yield self
        for p in self.bases:
            yield from PetalEnv(p).walk(include_core=include_core)


    def pip(self, cmd, args):
        "Return pip command line as a string list."

        python = str(self.path / 'bin' / 'python')
        opts = [
            '--disable-pip-version-check',
            '--no-warn-script-location',
            '--no-input',
            ]
        ret = [python, '-m' , 'pip'] + opts + [cmd]
        if isinstance(args, list):
            ret += args
        else:
            ret += args.split()
        return ret


    @contextmanager
    def tapped(self):
        orig_path = sys.path
        try:
            sys.path = list(reversed(self.paths())) + sys.path
            yield
        finally:
            sys.path = orig_path


    def list_installed(self, deep=True):
        # acurate dependencies requires extras, build a lut for it
        extras = defaultdict(set)
        for p in self.explicits(deep=deep):
            mo = re.search(r'\[(.+)\]', p.spec)
            if mo:
                extras[p.name] = {x.strip() for x in mo.group(1).split(',')}
        # list all installed packages
        with self.core.tapped():
            from pip._internal.metadata import pkg_resources as pkgres
            e = pkgres.Environment.from_paths(self.paths(include_core=False))
            # expand extras lut
            for d in e.iter_installed_distributions():
                for p in d.iter_dependencies():
                    extras[p.key] |= set(p.extras)
            pkgs = [Package(d._dist, list(extras.get(d._dist.key, {})))
                    for d in e.iter_installed_distributions()]
        if deep:
            return pkgs
        return [p for p in pkgs if p.env == str(self.path)]


    def split_install_args(self, args):
        "Split args into pip install options and package names."
        ins_spec = self._get_install_spec()
        idx = set()
        for i in range(len(args)):
            if args[i].startswith('-'):
                idx.add(i)
                if args[i] in ins_spec and i + 1 < len(args):
                    idx.add(i + 1)
        opts, pkgs = [], []
        for i in range(len(args)):
            if i in idx:
                opts.append(args[i])
            else:
                pkgs.append(args[i].lower())
        return (opts, pkgs)


    # We need to extract package names from command line, but in theory all pip
    # install options should be supported.  The solution we adopt is to extract
    # and cache command line switches from `pip install --help` and use those
    # to filter out options.
    def _get_install_spec(self):
        "Return pip install command-line spec of current version of pip."

        cache_fname = self.core.path / INSTALL_SPEC_CACHE
        if not cache_fname.exists():
            write_file(cache_fname, '{}')
        with open(cache_fname) as f:
            cache = json.load(f)
        pip_ver = self._get_pip_version()
        if not pip_ver:
            die(f'failed to get pip version in core env {self.core.path}')
        if pip_ver in cache:
            return cache[pip_ver]

        spec = []
        pip_cmd = self.core.pip('install', '--help')
        for x in check_output(pip_cmd).split('\n'):
            # this regexp filters out all options with argument
            if re.match(r'^\s{2,4}-[^ ].+\s+<[^ ]+>', x):
                spec += [c.strip(',') for c in x.split() if c.startswith('-')]
        spec = sorted(spec)

        # cache the result
        cache[pip_ver] = spec
        dump_json(cache_fname, cache)

        return spec


    def _get_pip_version(self):
        "Look up pip version in core env."

        if self.core is None:
            die(f'core env not found for {self.path}')
        for d in self.core.site_path.iterdir():
            if d.is_dir():
                version = grep(r'^pip-(.+)\.dist-info$', d.name)
                if version:
                    return version
        return None


    def add(self, pkg_specs, freeze=True):
        if not isinstance(pkg_specs, list):
            self.add([pkg_specs], freeze=freeze)
            return
        specs = self.require.lut
        for p in pkg_specs:
            specs[pkg_name(p)] = p
        self.update_require(list(specs.values()), freeze)


    def remove(self, pkg_specs, freeze=True):
        if not isinstance(pkg_specs, list):
            self.remove([pkg_specs], freeze=freeze)
            return
        dels = set(pkg_name(p) for p in pkg_specs)
        lut = self.require.lut
        self.update_require([lut[p] for p in lut if p not in dels])


    def update_require(self, req, freeze=True):
        self.cfg['require'] = req
        self.require = Explicits(req, pwd=self.path.parent)
        dump_json(self.conf_file, self.cfg)
        if freeze:
            self.freeze()


    def freeze(self, deep=False):
        pkgs = [f'{p.name}=={p.version}'
                for p in self.list_installed(deep=deep)]
        write_file(self.freeze_file, sorted(pkgs))


    def __str__(self):
        return self._y(tilde_path(str(self.path)))


    def __repr__(self):
        if self.is_core:
            env_type = 'Core'
        elif self.is_naive:
            env_type = 'Naive'
        else:
            env_type = 'Env'
        return f'Petal{env_type}({self.path})'


def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)


def make_dir(path):
    try:
        os.makedirs(path)
    except Exception as e:
        die(f'failed to make env dierctory: {str(e)}')


def check_output(cmd):
    if isinstance(cmd, str):
        cmd = cmd.split()
    return subprocess.check_output(cmd).decode().strip()


def grep(regexp, string, spec=1):
    try:
        mo = re.search(regexp, string)
        if isinstance(spec, list):
            return [mo.group(x) for x in spec]
        else:
            return mo.group(spec)
    except:
        return None


def pkg_name(name):
    return grep(r'^([a-zA-Z0-9_\-]+)', name).lower().replace('-', '_')


def download_url(url, filename=None, *, timeout=10):
    data = None
    try:
        error = None
        data = urllib.request.urlopen(url, timeout=timeout).read()
    except Exception as e:
        error = str(e)
    if data is None:
        raise RuntimeError(f'failed to grab {url} ({error})')
    if filename:
        with open(filename, 'wb+') as f:
            f.write(data)
    return data


def write_file(fname, content=None):
    if isinstance(content, list):
        if content and not content[-1]:
            content = content[:-1]
        write_file(fname, '\n'.join(content))
        return
    with open(fname, 'w+') as f:
        if content:
            f.write(content.strip())
            f.write('\n')


def read_lines(fname):
    "Read lines in file, remove Python comments and empty lines."

    lines = []
    with suppress(Exception):
        with open(fname) as f:
            for line in f:
                line = line.strip()
                if not line or re.match(r'^\s*#', line):
                    continue
                lines.append(line)
    return lines


def dump_json(fname, obj, indent=2):
    with open(fname, 'w+') as f:
        json.dump(obj, f, indent=indent)
        f.write('\n')


def log(*msg):
    line = ''.join([str(x) for x in msg])
    if line:
        print(line)


def os_run(cmd, **env):
    if isinstance(cmd, str):
        cmd = cmd.split()
    if env:
        env_vars = os.environ.copy()
        for key, val in env.items():
            env_vars[key] = str(val)
        return subprocess.call(cmd, env=env_vars)
    else:
        return subprocess.call(cmd)


def tilde_path(path):
    home = str(Path('~').expanduser())
    p = str(path)
    return re.sub('^' + home, '~', p) if p.startswith(home) else p


async def aio_tcp_ping(host, port, timeout):
    if isinstance(host, list):
        tasks = [aio_tcp_ping(h, port, timeout) for h in host]
        return await asyncio.gather(*tasks)
    try:
        beg = time.monotonic()
        await asyncio.wait_for(asyncio.open_connection(host, port), timeout)
        return (time.monotonic() - beg) * 1E3
    except:
        return None


def tcp_ping(host, port, timeout=1):
    ms = asyncio.run(aio_tcp_ping(host, port, timeout))
    if not isinstance(host, list):
        return {host: ms}
    ping = {host[i]: ms[i] for i in range(len(host))}
    return dict(sorted(ping.items(), key=lambda x: x[1] or 1E9))


if __name__ == '__main__':
    Petal().run()

### petal ends here
