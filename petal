#!/usr/bin/python3 -B
import sys, os, re, json
from pathlib import Path

# remove dist-packages, make sure only std libraries are used
sys.path = [p for p in sys.path if not re.search(r'/dist-packages$', p)]


CMD_ALIASES = {'install': 'add', 'remove': 'del', 'uninstall': 'del'}
INSTALL_SPEC_CACHE = 'install-command-spec.json'


def die_usage():
    print("""Usage: petal <command> [args ...]\n
    Create / build / re-build an environment
        petal make [env] [with /usr/bin/python3] [over layer ...]

    Install package(s)
        petal add [pip install params ...] [to env]
        petal install ... (an alias of add)

    Remove package(s)
        petal del [pip uninstall params ...] [from env]
        petal remove ... (an alias of del)
        petal uninstall ... (an alias of del)""")

    sys.exit(1)


class ColorMaker:
    def __init__(self):
        self.istty = sys.stdout.isatty()

    def _color(self, color=0):
        return self.istty and (f'\033[{color}m' if color else '\033[0m') or ''

    def _r(self, txt): return self._color(31) + txt + self._color()
    def _g(self, txt): return self._color(32) + txt + self._color()
    def _y(self, txt): return self._color(33) + txt + self._color()
    def _b(self, txt): return self._color(34) + txt + self._color()
    def _c(self, txt): return self._color(35) + txt + self._color()
    def _m(self, txt): return self._color(36) + txt + self._color()


class Petal(ColorMaker):
    def __init__(self):
        self.exit_code = 0
        # TODO: configurable Python version
        self.python = '/usr/bin/python3.8'
        # TODO: configurable pip URL
        self.pypi = 'https://pypi.tuna.tsinghua.edu.cn'


    @property
    def user_site(self):
        return re.sub(r'^.+/(lib.+/site-packages)$', r'\1',
                      check_output(f'{self.python} -m site --user-site'))


    @property
    def py_version(self):
        return check_output([self.python, '-c',
            'import sys; v = sys.version_info; print(f"{v[0]}.{v[1]}")'])


    def run(self):
        args = sys.argv[1:]
        if not args:
            die_usage()
        cmd_name = CMD_ALIASES.get(args[0], args[0])
        cmd = getattr(self, f'cmd_{cmd_name}', None)
        if not cmd:
            die(f'invalid command {cmd_name}')
        cmd(args[1:])
        exit(self.exit_code)


    def cmd_make(self, args):
        env_dir = args[0] if args else 'env'
        if not os.path.exists(env_dir):
            if len(args) > 2:
                if args[1] != 'over' or len(args) < 3:
                    die_usage()
                layers = args[2:]
            else:
                layers = []
            self.env_new(env_dir, layers)
        else:
            if len(args) > 1:
                die_usage()
            self.env_build(env_dir)


    def cmd_add(self, args):
        if len(args) > 2 and args[-2] == 'to':
            env = PetalEnv(args[-1])
            args = args[:-2]
        else:
            env = default_env()

        # get package we want to install from command line
        packages = env.extract_package_names(args)
        print(packages)


    def ensure_core(self):
        env = f'~/.cache/petal.py/core/python{self.py_version}'
        if Path(env).expanduser().exists():
            return env

        try:
            self.env_new(env, is_core=True)
        except:
            import shutil
            shutil.rmtree(env, ignore_errors=True)
            env = None
        if env is None:
            die(f'failed to make core env {env}')

        return env


    def env_new(self, path, layers=None, *, is_core=False):
        if not os.path.exists(self.python):
            self.die(f'{self.python} not found')
        env = Path(path).expanduser()
        if not is_core:
            core = self.ensure_core()
            if not layers:
                layers = [core]
            layers = [self.calc_layer_path(env, l) for l in layers]
        make_dir(env / self.user_site)
        make_dir(env / 'bin')
        os.symlink(self.python, env / 'bin' / 'python')
        with open(env / 'pyvenv.cfg', 'w+') as cfg:
            cfg.write(f'home = {os.path.dirname(self.python)}\n')
            cfg.write(f'include-system-site-packages = false\n')
            cfg.write(f'version = {self.py_version}\n')
            if is_core:
                cfg.write(f'core = true\n')
            elif layers:
                cfg.write(f'above = {", ".join(layers)}\n')
        if is_core:
            self.bootstrap_pip(os.path.realpath(env))
            log(f'petal core for python {self.py_version} made: ',
                self._y(path))
        else:
            msg = 'environment ' + self._y(path) + ' made'
            if layers:
                self.install_layers_hack(env)
                msg += (' on top of [%s]' %
                        ', '.join([self._y(layer) for layer in layers]))
            log(msg)


    def calc_layer_path(self, env, layer):
        if layer[0] in ['~', '/']:
            return layer
        base = Path(layer).expanduser().resolve()
        return os.path.relpath(base, env.resolve())


    def bootstrap_pip(self, env):
        "Download pip wheel package and install it."

        import tempfile

        data = json.loads(download_url(f'{self.pypi}/pypi/pip/json'))
        pip_url = re.sub(r'https?://[^/]*', self.pypi, data['urls'][0]['url'])
        fname = os.path.basename(pip_url)
        pip_ver = fname.split('-')[1]
        with tempfile.TemporaryDirectory(suffix=".petal") as tmp:
            log('download pip ' + self._b(pip_ver) + f' from {self.pypi}')
            py = f'{env}/bin/python'
            whl = f'{tmp}/{fname}'
            download_url(pip_url, whl)
            cmd = f'{py} {whl}/pip install --no-index -q {whl}'
            os.system(cmd)
            log('pip bootstrap done for ' + self._y(env))


    def install_layers_hack(self, env):
        "The magic of layered environments."

        site = env / 'lib' / f'python{self.py_version}' / 'site-packages'
        write_file(site / 'petal-layers.pth',
                   "import sys; __import__('_petal_layers').scan_layers()")
        write_file(site / '_petal_layers.py', """
import sys, os; from pathlib import Path; envs = set()
class EnvLayer:
    def __init__(self, root, name):
        self.is_core = False
        if str(root) in envs:
            self.root = None
        else:
            self.root, self.name = root, name
            envs.add(str(self.root))
    def add_path(self):
        if not self.root:
            return
        layers = []
        try:
            with open(self.root / 'pyvenv.cfg') as cfg:
                for line in cfg.readlines():
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    key, val = [x.strip() for x in line.split('=')]
                    if key == 'core' and val.lower() == 'true':
                        self.is_core = True
                        layers = []
                        break
                    if key != 'above': continue
                    for d in [x.strip() for x in val.split(',')]:
                        layer = d[0] in ['/', '~'] and Path(d) or self.root / d
                        layer = layer.expanduser().resolve()
                        if layer.is_dir():
                            layers.append(layer)
        except: pass
        if not self.is_core or 'PETAL_USE_CORE' in os.environ:
            site_path = self.root / 'lib' / self.name / 'site-packages'
            if site_path.is_dir():
                path = str(site_path)
                if path not in sys.path:
                    sys.path.append(path)
        try:
            for layer in layers: EnvLayer(layer, self.name).add_path()
        except: pass
def scan_layers():
    py_dir = Path(__file__).parent.parent
    EnvLayer(py_dir.parent.parent, py_dir.name).add_path(); envs = set()
""")


class PetalEnv:
    def __init__(self, path):
        self.path = Path(path).expanduser().resolve()
        self.cfg = self.path / 'pyvenv.cfg'
        if not self.cfg.is_file():
            die(f'invalid env {path}')
        self.is_core = False
        self.bases = []
        self.py_version = None
        with open(self.cfg) as cfg:
            for line in cfg.readlines():
                line = line.strip()
                if line.startswith('#'):
                    continue
                key, val = [x.strip() for x in line.split('=')]
                if key == 'core' and val.lower() == 'true':
                    self.is_core = True
                    self.bases = []
                    break
                if key != 'above':
                    if key == 'version':
                        self.py_version = val
                    continue
                for d in [x.strip() for x in val.split(',')]:
                    layer = d[0] in ['/', '~'] and Path(d) or self.path / d
                    layer = layer.expanduser().resolve()
                    if layer.is_dir():
                        self.bases.append(layer)
        if self.py_version is None:
            die(f'Python version not found in {self.cfg}')

    @property
    def layers(self):
        "Iterate all direct base layers"
        for p in self.bases:
            yield PetalEnv(p)

    @property
    def core(self):
        "Find core env recursively"
        if self.is_core:
            return self
        for e in self.layers:
            ret = e.core
            if ret:
                return ret
        return None

    @property
    def site_path(self):
        "Path to package directory in this env"
        return self.path / 'lib' / f'python{self.py_version}' / 'site-packages'

    def extract_package_names(self, args):
        "Remove all command line switches of pip install"
        ins_spec = self._get_install_spec()
        for i in range(len(args)):
            if args[i].startswith('-'):
                if args[i] in ins_spec and i + 1 < len(args):
                    args[i+1] = ''
                args[i] = ''
        return list(filter(None, args))

    # We need to extract package names from command line, but in theory all pip
    # install options should be supported.  The solution we use is to extract
    # and cache command line switches from `pip install --help` and use those
    # to filter out options.
    def _get_install_spec(self):
        "Return pip install command-line spec of current version of pip"

        cache_fname = self.core.path / INSTALL_SPEC_CACHE
        if not cache_fname.exists():
            write_file(cache_fname, '{}')
        with open(cache_fname) as f:
            cache = json.load(f)
        pip_ver = self._get_pip_version()
        if not pip_ver:
            die(f'failed to get pip version in core env {self.core.path}')
        if pip_ver in cache:
            return cache[pip_ver]

        core_py = self.core.path / 'bin' / 'python'
        cmd = [str(core_py), '-m' , 'pip', 'install', '--help']
        spec = []
        for line in check_output(cmd).split('\n'):
            # this regexp filters out all options with argument
            if re.match('^\s{2,4}-[^ ].+\s+<[^ ]+>', line):
                spec += [x for x in line.split() if x.startswith('-')]
        spec = sorted(spec)

        # cache the result
        cache[pip_ver] = spec
        with open(cache_fname, 'w+') as f:
            json.dump(cache, f, indent=2)

        return spec

    def _get_pip_version(self):
        "Look up pip version in core env"
        if self.core is None:
            die(f'core env not found for {self.path}')
        for d in self.core.site_path.iterdir():
            if d.is_dir():
                version = grep(r'^pip-(.+)\.dist-info$', d.name)
                if version:
                    return version
        return None

    def __str__(self):
        return 'Petal%s(%s)' % (self.is_core and 'Core' or 'Env', self.path)


def die(msg):
    sys.stderr.write(msg + '\n')
    sys.exit(1)


def make_dir(path):
    try:
        os.makedirs(path)
    except Exception as e:
        die(f'failed to make env dierctory: {str(e)}')


def check_output(cmd):
    import subprocess
    if isinstance(cmd, str):
        cmd = cmd.split()
    return subprocess.check_output(cmd).decode().strip()


def grep(regexp, string, spec=1):
    try:
        mo = re.search(regexp, string)
        if isinstance(spec, list):
            return [mo.group(x) for x in spec]
        else:
            return mo.group(spec)
    except:
        return None


def download_url(url, filename=None, *, timeout=10):
    import urllib.request
    data = urllib.request.urlopen(url, timeout=timeout).read()
    if filename:
        with open(filename, 'wb+') as f:
            f.write(data)
    return data


def write_file(fname, content):
    with open(fname, 'w+') as f:
        f.write(content.strip())
        f.write('\n')


def log(*msg):
    print(''.join([str(x) for x in msg]))


def default_env():
    envs = [d for d in Path(os.getcwd()).iterdir()
            if d.is_dir() and (d / 'pyvenv.cfg').exists()]
    if not envs:
        die('No env found!')
    if len(envs) > 1:
        die('Multiple envs found, you need to choose one explicitly')
    return PetalEnv(envs[0])


def list_packages(path):
    try:
        from pip._internal.metadata import pkg_resources
        e = pkg_resources.Environment.from_paths([path])
        return [d._dist for d in e.iter_installed_distributions(user_only=True)]
    except:
        return []

# class PkgTree:
#     def __init__(self):
#         self.pkgs = defaultdict(set)

#     def scan(self, path):
#         try:
#             from pip._internal.metadata import pkg_resources
#             env = pkg_resources.Environment.from_paths(path)
#             return [d._dist for d in 
#                     env.iter_installed_distributions(user_only=False)]
#         except ImportError:
#             from pip._internal.utils import misc
#             return misc.get_installed_distributions(user_only=True)

if __name__ == '__main__':
    # print(list_packages('/usr/local/lib/python3.8/dist-packages'))
    Petal().run()

### petal ends here
